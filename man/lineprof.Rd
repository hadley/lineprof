\name{lineprof}
\alias{lineprof}
\title{Line profiling.}
\usage{
  lineprof(code, interval = 0.001, torture = FALSE)
}
\arguments{
  \item{code}{code to profile.}

  \item{interval}{interval, in seconds, between profile
  snapshots. R's timer has a resolution of at best 1 ms, so
  there's no reason to make this value smaller, but if
  you're profiling a long running function you might want
  to set it to something larger.}

  \item{torture}{if \code{TRUE}, turns on
  \code{\link{gctorture}} which forces \code{\link{gc}} to
  run after (almost) every allocation. This is useful if
  you want to see exactly when memory is released. It also
  makes R run extremely slowly (10-100x slower than usual)
  so it can also be useful to simulate a smaller
  \code{interval}.}
}
\description{
  \code{lineprof} uses R built-in time and memory profiler
  \code{\link{Rprof}} to collect line profiling data and
  displays it in ways that help you figure out where the
  bottlenecks in your code R.
}
\details{
  R's profiler is a sampling profiler, which means that it
  stops execution every \code{interval} seconds and records
  the current call stack. This means that it is somewhat
  random: if you run the profiler repeatedly on the same
  code you'll see slightly different outputs depending on
  exactly where the profiler stopped each time.
}
\section{Profiling output}{
  For each sequence of calls, \code{lineprof} calculates:

  \itemize{ \item \code{time}: the time in seconds \item
  \code{alloc}: the memory allocated, in megabytes \item
  \code{released}: the memory released, in megabytes.
  Unless \code{torture = TRUE} this release is somewhat
  random: memory will be only released if a garbage
  collection is triggered by an allocation.  \item
  \code{dups}: the number of calls to the internal
  \code{duplicate} function which is called by C code to
  duplicate R vectors. }

  Note that memory allocation is only approximate due to
  the nature of the sampling profiler: if a large block of
  memory is allocated and then released in between ticks of
  the timer, no change in memory will be recorded. Using
  \code{torture = TRUE} helps prevent this, mostly by
  making R super slow.
}

\section{Navigation}{
  There are two ways to navigate through the line profiling
  output: using a shiny GUI, generated by
  \code{\link{shine}}; or through the command line, using
  \code{\link{navigate}} and \code{\link{align}}.
}
\examples{
source(find_demo("read-delim.r"))
source(find_demo("read-table.r"))
wine <- find_demo("wine.csv")

x1 <- lineprof(read.table2(wine, sep = ","), torture = TRUE)
x2 <- lineprof(read_delim(wine), torture = TRUE)

\dontrun{
shine(x1)
shine(x2)
}
}

