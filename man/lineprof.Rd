% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/lineprof.r
\name{lineprof}
\alias{lineprof}
\title{Line profiling.}
\usage{
lineprof(code, interval = 0.001, torture = FALSE, prof_path = "")
}
\arguments{
\item{code}{code to profile.}

\item{interval}{interval, in seconds, between profile snapshots. R's timer
has a resolution of at best 1 ms, so there's no reason to make this value
smaller, but if you're profiling a long running function you might want to
set it to something larger.}

\item{torture}{if \code{TRUE}, turns on \code{\link{gctorture}} which forces
\code{\link{gc}} to run after (almost) every allocation. This is useful
if you want to see exactly when memory is released. It also makes R run
extremely slowly (10-100x slower than usual) so it can also be useful to
simulate a smaller \code{interval}.}

\item{prof_path}{path to file where the raw profiling output should be saved.
The default value, \code{""}, writes the raw data to a temporary file that
that is deleted when the program exits.}
}
\description{
\code{lineprof} uses R built-in time and memory profiler \code{\link{Rprof}}
to collect line profiling data and displays it in ways that help you
figure out where the bottlenecks in your code R.
}
\details{
R's profiler is a sampling profiler, which means that it stops execution
every \code{interval} seconds and records the current call stack. This means
that it is somewhat random: if you run the profiler repeatedly on the same
code you'll see slightly different outputs depending on exactly where the
profiler stopped each time.
}
\section{Profiling output}{


For each sequence of calls, \code{lineprof} calculates:

\itemize{
  \item \code{time}: the time in seconds
  \item \code{alloc}: the memory allocated, in megabytes
  \item \code{released}: the memory released, in megabytes. Unless
    \code{torture = TRUE} this release is somewhat random:
    memory will be only released if a garbage collection is triggered by
    an allocation.
  \item \code{dups}: the number of calls to the internal \code{duplicate}
    function which is called by C code to duplicate R vectors.
}

Note that memory allocation is only approximate due to the nature of the
sampling profiler: if a large block of memory is allocated and then released
in between ticks of the timer, no change in memory will be recorded. Using
\code{torture = TRUE} helps prevent this, mostly by making R super slow.
}

\section{Navigation}{


There are two ways to navigate through the line profiling output:
using a shiny GUI, generated by \code{\link{shine}}; or through the
command line, using \code{\link{focus}}.
}

\section{Display}{


The default print method uses \code{reduce_depth} to reduce the call stack
to show only two steps down, and then formats the output with
\code{format.lineprof}. An alternative option is to use
\code{\link{align}}, which when src refs are available, will align the
profiling data with the original source code.
}
\examples{
source(find_ex("read-delim.r"))
source(find_ex("read-table.r")) # local copy so get line numbers
wine <- find_ex("wine.csv")

\dontrun{
x1 <- lineprof(read.table2(wine, sep = ","), torture = TRUE)
x2 <- lineprof(read_delim(wine), torture = TRUE)

shine(x1)
shine(x2)
}
}

